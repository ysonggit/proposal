\begin{filecontents*}{shell.command}
#!/usr/bin/env sh
/Applications/VLC.app/Contents/MacOS/VLC -f /Users/song/Codes/latex/proposal/videos/hexsq.mp4
\end{filecontents*}
\begin{filecontents*}{shell.command2}
#!/usr/bin/env sh
/Applications/VLC.app/Contents/MacOS/VLC -f /Users/song/Codes/latex/proposal/videos/octsq.mp4
\end{filecontents*}
% use pdflatex -shell-escape slides.tex to compile
\documentclass[10pt]{beamer}
\usetheme{CambridgeUS}
%\usetheme[
%%% options passed to the outer theme
%    shownavsym          % show the navigation symbols
%]{AAUsimple}

\overfullrule=5pt
% If you want to change the colors of the various elements in the theme, edit and uncomment the following lines
% Change the bar and sidebar colors:
%\setbeamercolor{AAUsimple}{fg=red!20,bg=red}
%\setbeamercolor{sidebar}{bg=red!20}
% Change the color of the structural elements:
%\setbeamercolor{structure}{fg=red}
% Change the frame title text color:
%\setbeamercolor{frametitle}{fg=blue}
% Change the normal text color background:
%\setbeamercolor{normal text}{fg=black,bg=gray!10}
% ... and you can of course change a lot more - see the beamer user
% manual.
\usepackage{animate}
\usepackage{tabularx}
\usepackage{epstopdf}
\usepackage{movie15}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
%\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
\usepackage{helvet}
\usepackage[helvet]{sfmath}
\usepackage{graphicx}
% For math font script
\usepackage[mathscr]{euscript}
\usepackage{algorithm,algorithmic}
\usepackage{color, xcolor}
\usepackage{tikz}
% tikz setup for descendant robot motion figure 
\usetikzlibrary{positioning,chains,fit,shapes,calc, snakes}
\usetikzlibrary{arrows,shadows,trees}
\tikzset{
  basic/.style  = {draw, text width=2cm, drop shadow, font=\sffamily, rectangle},
  root/.style   = {basic, rounded corners=2pt, thin, align=center,
                   fill=red!30},
  level 2/.style = {basic, rounded corners=6pt, thin,align=center, fill=orange!30,
                   text width=8em},
  level 3/.style = {basic, thin, align=left, fill=pink!60, text width=8em},
  post/.style={->,>=stealth', thick},
  arc/.style={->,>=stealth' },
  node/.style={circle,draw,font=\sffamily\small},
  pile/.style={thin, ->, >=stealth', shorten <=2pt, shorten
  >=2pt},
  edge/.style={->, >=stealth', thin},
  edges/.style={->, shorten <=2pt, shorten >=2pt}
}
% tikz setup for lattice graph
\usepackage{pgf}
\usetikzlibrary{automata}
\usepackage{hyperref}
\hypersetup{pdfpagemode=FullScreen}
\usepackage{ifthen}
% tikz animation
\usetikzlibrary{arrows,decorations.pathmorphing,through,backgrounds,positioning,fit,petri}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{decorations.pathreplacing}

\usepackage[tikz]{bclogo}
\newcommand{\Ispace}{\mathcal{I}}
\newcommand{\Rspace}{\mathcal{R}}
\newcommand{\sub}[1]{_{\mbox{\small #1}}}
\newcommand{\disk}{\sub{disk}}
\newcommand{\ident}{\sub{ident}}
\newcommand{\triv}{\sub{triv}}
\newcommand{\rect}{\sub{rect}}
\newcommand{\drect}{\sub{dblrect}}
\newcommand{\free}{\sub{free}}
\newcommand{\obst}{\sub{obst}}
\newcommand{\Rdisk}{\Rspace\disk}
\newcommand{\Rtriv}{\Rspace\triv}
\newcommand{\Rident}{\Rspace\ident}
\newcommand{\Rrect}{\Rspace\rect}
\newcommand{\Rdrect}{\Rspace\drect}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\pow}{\operatorname{pow}}

\newcommand{\aabb}{\textsc{aabb}}
\newcommand{\drap}{\textsc{drap}}
\newcommand{\area}{\operatorname{area}}

\newcommand{\id}{{\rm id}}
\newcommand{\edge}[3]{{#1}\overset{#2}{\longrightarrow}{#3}}
\renewcommand{\L}{{\Lambda}}
% colored hyperlinks
\newcommand{\chref}[2]{%
  \href{#1}{{\usebeamercolor[bg]{AAUsimple}#2}}%
}
\newcommand{\lgpath}[4]{{#1}\overset{#2}{\longrightarrow}{\cdots}\overset{#3}{\longrightarrow}{#4}}

\title[Ph.D. Proposal]{Constrained Geometric Approximation Approach for Robot Planning and  Decentralized Formation Algorithm for Multi-Robot Systems}

%\subtitle{v.\ 1.0.0}  % could also be a conference name
%\date{\today}
\author[Yang Song]{
  \underline{Yang Song}\\
  Advisor: Jason M. O'Kane %\\
 % \href{mailto:song24@email.sc.edu}{{\tt song24@email.sc.edu} \\
 % \href{mailto:jokane@cse.sc.edu}{\tt jokane@cse.sc.edu}}
}

% - Give the names in the same order as they appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation. See the beamer manual for an example

\institute[
%  {\includegraphics[scale=0.2]{aau_segl}}\\ %insert a company, department or
%  university logo
USC
% Dept.\ of Computer Science and Engineering\\
  % University of South Carolina
] % optional - is placed in the bottom of the sidebar on every slide
{ % is placed on the bottom of the title page
  Dept. of Computer Science and Engineering\\
  University of South Carolina
  
  %there must be an empty line above this line - otherwise some unwanted space is added between the university and the country (I do not know why;( )
}

% specify a logo on the titlepage (you can specify additional logos an include them in 
% institute command below
\pgfdeclareimage[height=1.5cm]{titlepagelogo}{sc_logo.pdf}%{aau_logo_new.pdf} % placed on the title page
%\pgfdeclareimage[height=1.5cm]{titlepagelogo2}{aau_logo_new.pdf} % placed on the title page
\titlegraphic{% is placed on the bottom of the title page
  \pgfuseimage{titlepagelogo}
%  \hspace{1cm}\pgfuseimage{titlepagelogo2}
}

\definecolor{scred}{RGB}{115,0,10}% dark red 
\definecolor{myblue}{RGB}{80,80,160}
\definecolor{mygreen}{RGB}{80,160,80}

\begin{document}
% the titlepage
\begin{frame}[plain] % the plain option removes the sidebar and header from the title page
  \titlepage
\end{frame}
%%%%%%%%%%%%%%%%
% TOC
% \begin{frame}{Agenda}{}
% \tableofcontents
% \end{frame}
%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Outlines}
  \tableofcontents[]
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CGA for Robot Planning}
%\tableofcontents[currentsection]
\subsection[Problem]{Overview}
\begin{frame}{Constrained Geometric Approximation}
\begin{columns}
  \begin{column}{.65\textwidth}
    \begin{itemize}
    \item \textbf{Goal}:\\
    For an extremely simple robot with:
    \begin{itemize}
    \item computation limitations
    \item moving and sensing uncertainties
    \end{itemize}
    represent and reason about uncertainty in its own states efficiently.\\
    \item \textbf{Basic Idea}:\\
    Explicitly represent what the robot knows as an information state (\textit{I-state}).
    \item \textbf{Intuition}:\\
    Accelerate time-consuming operations by maintaining only an \textcolor[rgb]{1.00,0.00,0.00}{overapproximation} of the true
    \emph{I-state}, and constraining this approximation
    to have a simple geometric form.\\
    \end{itemize}
  \end{column}
  \begin{column}{.35\textwidth}
    %\textbf{Result}:\\
    % The robot can fulfill the navigation task even with poor approximation of the true \emph{I-state}.
    \begin{figure}
    \includegraphics[scale=0.2]{figs/srvq.jpg}
    \end{figure}
    SRV-1 Surveyor Robot
  \end{column}
\end{columns}
\end{frame}

\begin{frame}{Prior Work}
\begin{itemize}
\item Prior research done by Kuffner and LaValle (RRT) and J. van den Berg,
  P. Abbeel, and K. Goldberg (LQG-MP)
  used probabilistic representations for planning
\item Prior work by O'Kane has used preliminary versions of the
  constrained geometric approximation method using specific, fixed range spaces.
\end{itemize}
New contributions
\begin{enumerate}
\item A careful formulation of the operations in the range space $\mathcal{R}$
\item Algorithms for double-rectangle range space $\mathcal{R}_{drect}$
\item A series of experiments for effectiveness comparison of different range spaces
\end{enumerate}
\end{frame}

%\subsection[Problem]{Problem Statement}
\begin{frame}{Robot Model}
Assume that current real state of the robot could not be observed directly.  The
robot could maintain an \emph{I-state} $\eta_k$, to make its decisions.
\begin{itemize}
\item State space: $X = \mathbb{R}^2$,  $X_{obt} \cup X_{free} \subseteq X$
\item Action space: $U$, apply a bounded noise $\theta_k$ to the action
  $u_k \in U$
\item Set valued state transition function: $F(x, u)$
  \begin{equation}
    \label{eq:state-trans}
    F(x_k, u_k) = \left\{
      x_k + u_k + \theta_k
      \mid
      \theta_k \in \Theta(u_k)
    \right\} \cap X_{free}
  \end{equation}
  \begin{columns}
  \begin{column}{0.4\textwidth}
        \begin{figure}
          \centering
          \includegraphics[scale=0.2]{figs/istate.jpg}
          \caption{\scriptsize{The transition of robot's state $x_k$ with
              uncertainty [\emph{Planning Algorithms}, S. LaValle, 2006].}}
        \end{figure}
      \end{column}
      \begin{column}{0.5\textwidth}
          \begin{figure}
            \centering
            \includegraphics[scale=0.55]{figs/noisemodel}
            \caption{\scriptsize{The noise model $\Theta(u_k)$ involves bounded
                angular error $\delta_{ang}$ and bounded translational error
                $\delta_{trans}||u||$.}}
            \label{fig:noiseModel}
          \end{figure}
        \end{column}
    \end{columns}
\end{itemize}
  	
\end{frame}

\begin{frame}{Robot Model (Cont'd)}
  \begin{itemize}
  \item Observation space: $Y$
  \item Observation function: $h : X \to \pow(Y) $
  \item Observation Preimage: the set of states from which a given observation
    $y_k \in Y$ can be obtained
  \begin{equation}
    H(y_k) = \left\{ x_k \in X \mid y_k \in h(x_k), y_k \in Y \right\}
  \end{equation}
 
  \begin{figure}
    \centering
    \begin{tikzpicture}[scale=0.45]
    \draw[blue!20, fill=blue!20] (3, 3) circle (3);
    \draw[fill=violet] (3,3) circle (0.2);
    \draw[fill=red] (3,4.5) circle (0.1);
    \draw[fill=red] (3.2,1.7) circle (0.1);
    \draw[fill=red] (1,3) circle (0.1);
    \draw[fill=red] (2,0.5) circle (0.1);
    \draw[fill=red] (4,3.3) circle (0.1);
    \draw[fill=red] (4.4,4.8) circle (0.1);
  \end{tikzpicture}
  \caption{\scriptsize{The observation preimage set $H(y)$ (circle). Any states in this
    region (red points) can get observation of the landmark $y$ (violet
    point).}}
\end{figure}
\end{itemize}
\end{frame}

\begin{frame}{Information Space}
  \begin{definition}
  An information state (I-state) $\eta$ is a set containing all possible states
  consistent with robot's sensor and action history.
  \end{definition}
  Assume that current real state of the robot can not be observed directly. 
  The robot maintains a set of possible states, which is \emph{I-state} $\eta$,
 
  \begin{figure}
              \centering
              \begin{tikzpicture}
                % Create random(ish) points
                \foreach \i in {1,...,26}
                \fill [opacity=0.5] (360/26*\i:1+rnd*1) circle [radius=.025] coordinate (mark-\i);
                
                % Join them up
                \fill [opacity=0.5,blue]
                (mark-1) \foreach \i in {2,...,26}{ -- (mark-\i) } -- cycle;
                \draw[fill=black] (0,0) circle (0.05);
                \draw[fill=black] (-0.3,0) circle (0.05);
                \draw[fill=black] (-0.5,0.4) circle (0.05);
                \draw[fill=black] (0.5,-0.4) circle (0.05);
                \draw[fill=black] (-0.2,-0.7) circle (0.05);
                \draw[fill=black] (0.1,0.8) circle (0.05);
                \draw[fill=black] (-1,-0.4) circle (0.05);
                \draw[fill=black] (-1,0.1) circle (0.05);
              \end{tikzpicture}
              \caption{\scriptsize{$\eta_k$ : contains all possible states at stage $k$.}}
            \end{figure}

\end{frame}

\begin{frame}{Information Space}{1. Set Transition Function}
 \begin{definition}
  The \emph{information space} (I-space) $\Ispace$ is the
  powerset of $X$, which contains all possible I-states.
  \end{definition}
  1. Set transition function in the I-space:
  \begin{equation}
    \label{eq:settrans}
    X_{k+1}(\eta_{k}, u_k) =  \bigcup_{x_k \in \eta_k} F(x_k, u_k)
  \end{equation}
 \begin{columns}
      \begin{column}{0.35\textwidth}
        \begin{figure}
          \centering
          \begin{tikzpicture}[scale=0.8]
                % Create random(ish) points
                \foreach \i in {1,...,26}
                \fill [opacity=0.5] (360/26*\i:1+rnd*1) circle [radius=.025] coordinate (mark-\i);
                
                % Join them up
                \fill [opacity=0.5,blue]
                (mark-1) \foreach \i in {2,...,26}{ -- (mark-\i) } -- cycle;
                \draw[fill=black] (-0.5,0.4) circle (0.05);
                \draw[fill=black] (0.5,-0.4) circle (0.05);
                \draw[fill=black] (-0.2,-0.7) circle (0.05);
                \draw[fill=black] (0.1,0.8) circle (0.05);
                \draw[fill=black] (-0.8,-0.4) circle (0.05);
                \draw[fill=black] (-1,0.1) circle (0.05);
              \end{tikzpicture}
            \end{figure}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{figure}
          \includegraphics[scale=0.16]{figs/xkunion.jpg}
        \end{figure}
      \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Information Space}{2. Set Observation Function}
  2. Set observation function in the I-space : \\
  intersecting the result of set transition function with the observation preimage,
  \begin{equation}
    \label{eq:settrans}
    \eta_{k+1} =   X_{k+1}(\eta_{k}, u_k) \cap H(y_{k})
  \end{equation}
  
   \begin{figure}
     \centering
     \includegraphics[scale=0.2]{figs/xk_intersect.jpg}
     \caption{\scriptsize{The green region is updated \emph{I-state} $\eta_{k+1}$.}}
   \end{figure}
 \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection[Range Space]{Range Space}
%\subsection[Range Space Definition]{Range Space Definition}
\begin{frame}{Range Space}
  \begin{definition}{\textbf{A range space}}
    $\mathcal{R} \subseteq \mathcal{I}$ is a set of I-states, contains
    approximation of \emph{I-states}, $A(\eta_k) \in \mathcal{R}$, equipped with
    two operations:
  \end{definition}
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{enumerate}
      \item An \emph{approximate observation update function} $O: \mathcal{R} \times
        Y \to \mathcal{R}$, such that if $\eta_k \subseteq A(\eta_k)$, then
        $$\eta_k \cap H(y_k) \subseteq O(A(\eta_k), u_k)$$
      \item An \emph{approximate action update function} $T: \mathcal{R} \times U \to
        \mathcal{R}$, such that if $\eta_k \subseteq A(\eta_k)$, then
        $$\bigcup_{x_k \in \eta_k} F(x_k, u_k) \subseteq T(A(\eta_k), u_k)$$
      \end{enumerate}
    \end{column}
    \begin{column}{.4\textwidth}
    \begin{figure}
      \begin{tikzpicture}[scale=0.75]
      \begin{scope}
        \clip (0,0) rectangle (4,4);
        \draw[fill=green!20] (0,0) circle (3cm);
        \draw[fill=white] (0,0) circle (1cm);  
      \end{scope}
      \draw[blue] (0,0) -- (3,0) -- (3,3) -- (0,3) -- (0,0);
      \draw[red]  (1.5,1.5) circle (2.13cm);
      \node at (1.3,1.3) {$\eta_k$};    
    \end{tikzpicture} 
    \caption{\scriptsize{An \emph{I-state} $\eta_k$ (shaded region),
        overapproximations $A(\eta_k)$ using disk (red circle) and rectangle
        (blue). }}
    \end{figure}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}{Simulation: Navigation Task}
 \begin{block}{Ultimate Objective} 
   Form a plan $\pi$ for the robot to execute using the information available in
   the information space.
 \end{block}

\textbf{In a navigation task, we assume:}
\begin{itemize}
\item A point robot follows predefined waypoints guided by centroid point of the
  approximated \emph{I-state}
\item Robot can detect presence but not distance to the waypoints
\item Landmarks are pseudo-randomly generated
\item Initial I-state $\eta_0$ is given
\end{itemize}
\end{frame}


\begin{frame}{Example Application}{Rectangle Approximation of I-state}
  \begin{center}
  %\href{run:/usr/local/bin/mplayer -fs videos/rect.mp4}{
  %  \includegraphics[scale=0.25]{figs/clutter.jpg}}
    \includemovie[toolbar,poster,autoplay]{12cm}{6cm}{videos/clutter_rect.mp4}
  \end{center}
\end{frame}


\begin{frame}{Limitation}{Rectangle Approximation of I-state}
  \textbf{Problem: approximation accuracy}
  \begin{figure}
    \centering
    \includegraphics[width=0.85\textwidth]{figs/rect_clutter}
  \end{figure}
\end{frame}

\subsubsection[Double-Rectangle Range Space]{Double-Rectangle Range Space}
\begin{frame}{Double-Rectangle approximated I-state}
  %\begin{itemize}
  To improve the approximation quality for non-convex \emph{I-states},
  we proposed a novel range space of \textcolor[rgb]{1.00,0.00,0.00}{double rectangles}: \\
  \begin{equation}
    \mathcal{R}_{drect} = \{ R_1 \cup R_2 \mid R_1, R_2 \in \mathcal{R}_{rect} \}
  \end{equation}
  %\item Aims to improve the approximation quality
  \begin{figure}
    \includegraphics[width=0.75\textwidth]{figs/dbrect_clutter}
  \end{figure}
  %\end{itemize}
\end{frame}

\begin{frame}{Operations on Double-Rectangle Range Space}
  For a double rectangle approximated \emph{I-state} $A(\eta_k) = R_1 \cup R_2$:
  \begin{itemize}
  \item Action Transition: $T_{drect}\left(A(\eta_k), u_k \right) $\\
    \scriptsize{$$T_{drect}\left(A(\eta_k), u_k \right)=DRAP\left(X_{free} \cap [A(\eta_k) \oplus \{ u_k \} \oplus DRAP\left(\Theta(u_k)\right)]\right)$$}
  \item Observation Update: $O_{drect}\left(A(\eta_k), y_k\right) $\\
    \scriptsize{$$O_{drect}\left(A(\eta_k), y_k\right)=AABB\left(H(y_k) \cap R_1\right)\cup AABB\left(H(y_k) \cap R_2\right)$$ }
  \end{itemize}
  \begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{figs/algorithm.jpg}
  \end{figure} 
 %  \begin{algorithm}[H]
%   \begin{algorithmic}[1]
%     \STATE $V \leftarrow $ set containing the vertices of $P$ and its centroid
%     \FOR{each pair of vertices $p,q \in V, p \neq q$}
%           \STATE $R_1 \leftarrow \{ p \}$; $R_2 \leftarrow \{ q \}$
% 	  \FOR{each edge $e$ of $P$}
% 		\STATE $R_1' \leftarrow$ $\aabb(R_1 \cup e)$
% 		\STATE $R_2' \leftarrow$ $\aabb(R_2 \cup e)$
% 		\IF{$\area(R_1' \cup R_2) < \area(R_1 \cup R_2') $}
% 		    \STATE $R_1 \leftarrow R_1'$
% 		\ELSE
% 		    \STATE $R_2 \leftarrow R_2'$
% 		\ENDIF
% 	\ENDFOR
% 	\STATE insert $R_1 \cup R_2$ into $C$\\
%      \ENDFOR
%      \STATE \textbf{return} $\operatornamewithlimits{argmin}_{(R_1 \cup R_2) \in C}(\area(R_1 \cup R_2))$
%  \end{algorithmic}
%  \caption{\scriptsize{DoubleRectangleAroundPolygon}$(P)$}
%  \label{alg:drap}
% \end{algorithm}
\end{frame}

\begin{frame}{Simulation}{Double-Rectangle Approximation of I-state}
  \begin{center}
    \includemovie[toolbar,poster,autoplay]{12cm}{6cm}{videos/clutter_dbrect.mp4}
  \end{center}
\end{frame} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection[Experiments]{Experiments and Conclusions}
\begin{frame}{Experiments in Various Environments}
  Comparison with using the true I-state, we conducted experiments using 3
  environments, and 3 range spaces $\mathcal{R}_{disk}$, $\mathcal{R}_{rect}$,
  and  $\mathcal{R}_{drect}$. \\
  \begin{figure}
  \centering
  \begin{minipage}[b]{0.45\textwidth}
    \includegraphics[scale=0.45]{figs/blank}  \\ 
    \includegraphics[scale=0.45]{figs/clutter}  
  \end{minipage}
  \begin{minipage}[b]{0.45\textwidth}
    \includegraphics[scale=0.45]{figs/office}    
  \end{minipage}
  \caption{\scriptsize{Three environments with numbered landmarks: [top left]
    Obstacle-free. [bottom left] Obstacle-clutter. [right] Office-like.}}
  \label{fig:env}
\end{figure}
\end{frame}


% \begin{frame}{Experiments Results}{Success Rate}
% \item the approximation ratio $Q_k$
%   \begin{equation}
%     Q_k = \frac{1}{k} \sum_{i=1}^k \frac{\mathbb{A}(\eta_i)}{\mathbb{A}(A(\eta_i))}
%   \end{equation}
%   in which $\mathbb{A}(\diamond)$ denotes the area of set $\diamond \subset \mathbb{R}^2$
% \end{itemize}
% \end{frame}

\begin{frame}{Experimental Results}{Success Rate}
In each environment we collect the success rate of completing the navigation
task. 
\begin{enumerate}
\item The number of landmarks $N$: between $5$ and $250$ in increments of 5
\item For each $N$, run the experiment 15 trials with different landmark
  distributions by assigning distinct random seeds
\end{enumerate}
\begin{figure}
  \begin{center}
    \includegraphics[width=0.65\textwidth]{figs/exp_num_blank}
  \end{center}
  %\caption{\scriptsize{Results in the obstacle-free environment.}}
  \label{fig:sucRate1}
\end{figure}
\end{frame}

\begin{frame}{Experimental Results}{Success Rate (Cont'd)}
In each environment we collect the success rate of completing the navigation
task. 
\begin{enumerate}
\item The number of landmarks $N$: between $5$ and $250$ in increments of 5
\item For each $N$, run the experiment 15 trials with different landmark
  distributions by assigning distinct random seeds
\end{enumerate}
\begin{figure}
  \begin{center}
    \includegraphics[width=0.65\textwidth]{figs/exp_num_clutter}
  \end{center}
  %\caption{\scriptsize{Results in the obstacle-cluttered environment.}}
  \label{fig:sucRate1}
\end{figure}
\end{frame}

\begin{frame}{Experimental Results}{Success Rate (Cont'd)}
In each environment we collect the success rate of completing the navigation
task. 
\begin{enumerate}
\item The number of landmarks $N$: between $5$ and $250$ in increments of 5
\item For each $N$, run the experiment 15 trials with different landmark
  distributions by assigning distinct random seeds
\end{enumerate}
\begin{figure}
  \begin{center}
    \includegraphics[width=0.65\textwidth]{figs/exp_num_cse}
  \end{center}
  %\caption{\scriptsize{Results in the office-like environment.}}
  \label{fig:sucRate1}
\end{figure}
\end{frame}


\begin{frame}{Experimental Results}{Computation Time}
  For each environment, we
  \begin{itemize}
  \item randomly place $N = 300$ landmarks 
  \item run the  experiments $10$ times
  \end{itemize} 
  \begin{block}{}
    We compare the average time (in seconds) required to compute the approximated
    \emph{I-state} compared to the high-fidelity polygonal representation of the
    exact \emph{I-state}.
  \end{block}
\begin{table}
  \footnotesize\centering
    \begin{tabular}{cccc} 
    \hline
    Range & Obstacle-free & Obstacle-cluttered & Office-like\\
    Space & \multicolumn{3}{c}{Computation Time (s)}  \\ 
    \hline
    $\mathcal{R}_{disk}$ & 0.163  & 0.162   & 0.292  \\ 
    \hline
    $\mathcal{R}_{rect}$ & 0.396   & 0.441  & 0.415  \\
    \hline
    $\mathcal{R}_{dblrect}$ & 1.021  & 1.122  & 1.491  \\
    \hline
    $\mathcal{I}$ & 10.074  & 10.218  & 26.895  \\
    \hline
    \end{tabular}
    \caption{{Average computation time in three environments.}}
\end{table}
\end{frame}

\begin{frame}{Experimental Results}{Approximation Ratio}
  For each environment, we
  \begin{itemize}
  \item randomly place $N = 300$ landmarks 
  \item run the  experiments $10$ times
  \end{itemize} 
  \begin{block}{}
    We compare the average approximation ratio of using each approximation methods
    to approximate  the true \emph{I-state}
    $$\frac{1}{k} \sum_{i=1}^k \frac{\text{AREA}(\eta_i)}{\text{AREA}(A(\eta_i))}$$
  \end{block}
\begin{table}
  \footnotesize\centering
    \begin{tabular}{cccc} 
    \hline
    Range & Obstacle-free & Obstacle-cluttered & Office-like\\
    Space & \multicolumn{3}{c}{Approximation  Ratio}  \\
    \hline
      $\mathcal{R}_{disk}$ & 0.155  & 0.155   & 0.220 \\ 
    \hline
    $\mathcal{R}_{rect}$  & 0.642   & 0.632  & 0.661 \\
    \hline
    $\mathcal{R}_{dblrect}$ & 0.684 & 0.691  & 0.720 \\
    \hline
    $\mathcal{I}$ & 1.000  & 1.000  & 1.000 \\
    \hline
    \end{tabular}
    \caption{{Average approximation ratio in three environments.}}
\end{table}

\end{frame}

%\section[Conclusions]{Conclusions}
\begin{frame}{Conclusions}
  \begin{enumerate}
  \item CGA is effective for representing a robot's uncertain information about
    the current state
  \item The form of double-rectangle is more accurate in approximating the non-convex
    \emph{I-state}
  \item The robot can complete the navigation task using approximated I-state with
    low approximation accuracy
  \end{enumerate}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}
%   \frametitle{Outlines}
%   \tableofcontents[]
% \end{frame}

\section{Distributed Multi-Robot Formation}
\tableofcontents[currentsection] 
\subsection[problem]{Overview}
\begin{frame}{Related Work}{Formation using virtual force}
   \begin{columns}[T] 
    \begin{column}{.45\textwidth}
      \scriptsize{W. Spears, D. Spears, J. Hamann and R. Heil, 2004}
      \begin{figure}
        \centering
        \includegraphics[height=1in]{figs/spears1.png}
      \end{figure}
    \end{column}%
    \begin{column}{.45\textwidth}
      \scriptsize{I. Navarro, J. Pugh, A. Martinoli, and
        F. Matia, 2008}
      \begin{figure}
        \centering
        \includegraphics[height=1in]{figs/navarro.png}
      \end{figure}      
    \end{column}
  \end{columns}
  \vspace{3mm}
  \begin{columns}[T] 
    \begin{column}{.45\textwidth}
      \begin{figure}
        \centering
        \includegraphics[height=1in]{figs/spears2.png}     
      \end{figure}  
    \end{column}%
    \begin{column}{.45\textwidth}
      \scriptsize{S. Prabhu, W. Li, J. McLurkin, 2012}
      \begin{figure}
        \centering
        \includegraphics[height=1in]{figs/james.png}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Motivation}{}
  \textbf{Question: How to use one algorithm to generate
      various (repeating) lattice pattern formations?}
    \begin{columns}
    \begin{column}{.45\textwidth}
      \begin{figure}
        \centering
        \includegraphics[height=1.5in]{figs/tessellation2.png}
      \end{figure}
    \end{column}
    \begin{column}{.45\textwidth}
       \begin{figure}
         \centering
        \includegraphics[height=1.5in]{figs/tessellation1.png}
      \end{figure}
    \end{column}
  \end{columns} 
\end{frame}

\begin{frame}{Simulations}
  \begin{columns}
    \begin{column}{.45\textwidth}
      30 robots, form octagon-square pattern
       \begin{center}
         \includemovie[toolbar,poster,autoplay]{5cm}{5cm}{videos/octsq.mp4}
       \end{center}
        % \begin{figure}
        %   \href{run:shell.command}{\includegraphics[width=\linewidth]{figs/octsq}}
        %   \caption{Octagon-square pattern formed by 30 robots.}
        % \end{figure}
    \end{column}
    \begin{column}{.45\textwidth}
      30 robots, form triangle-hexagon-square pattern
       \begin{center}
         \includemovie[toolbar,poster,autoplay]{5cm}{5cm}{videos/trihexsq.mp4}
       \end{center}
        % \begin{figure}
        %   \href{run:shell.command2}{\includegraphics[width=0.8\linewidth]{figs/hexsq}}
        %   \caption{Hexagon-square pattern formed by 30 robots.}
        % \end{figure}
    \end{column}
  \end{columns}
\end{frame}
% \begin{frame}{Example}
%   \begin{columns}
%     \begin{column}{.45\textwidth}
%         \begin{figure}
%           \includegraphics[width=0.8\linewidth]{figs/initial50}
%           \caption{Initial random poses distribution of 50 robots.}
%         \end{figure}
%     \end{column}
%     \begin{column}{.45\textwidth}
%         \begin{figure}
%           \includegraphics[width=0.8\linewidth]{figs/final50}
%           \caption{Triangle-Hexagon-square pattern formed by 50 robots.}
%         \end{figure}
%     \end{column}
%   \end{columns}
% \end{frame}

%%%%%%%%%%%%%%%%
\begin{frame}{Robot Model}{}
%\begin{block}{}
  \begin{columns}[T] % align columns
      \begin{column}{.55\textwidth}
        \begin{itemize}
        \item Differential Drive robots
        \item Each robot has an unique \textbf{ID}
        \item Use a vector $p = [x, y,
          \theta]^T$ to represent robot's \textbf{pose}
        \item Each robot has a \textbf{range} within which it can
          sense and communicate with other robots
        \item Each robot gets \textbf{observation} of its neighbors'
          IDs and relative poses in its body frame
        \end{itemize}
      \end{column}%
      % right column
      \begin{column}{.45\textwidth}
        \begin{figure}
          \centering
          \begin{tikzpicture}[scale=0.55]
            \draw[dotted, violet, fill=violet!10] (3, 3) circle (3.2);
            \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)   	-- cycle;
            \node[color=red] at (3, 2.3) {$r_i$};           
            \draw[fill=blue!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) -- (0.67,4) 	-- cycle;
            \draw[fill=blue!50] (4,5) -- (3.75,5.5) -- (3.75,5.25) -- (3.5,5.25)   	-- cycle;
            \draw[fill=blue!50] (1,1.5) -- (1.25,1) -- (1.25,1.25) -- (1.5,1.25)   	-- cycle;
            \draw[fill=blue!50] (5,2.92) -- (4.5,2.75) -- (5,2.58) -- (4.875,2.75)  -- cycle;
            \draw[fill=green!50] (-0.5,0.5) -- (-0.5,0.75) -- (-0.75,0.25) -- (-0.25,0.5)  -- cycle;
          \end{tikzpicture}
        \end{figure}
        \begin{center}
          Robot $r_i$ has 4 neighbors
        \end{center}
      \end{column}%
    \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}
%   \frametitle{Outlines}
%   \tableofcontents[]
% \end{frame}

\subsection{Lattice Graph}
% definition of lattice graph
\begin{frame}{Input: Lattice Graph}
  \begin{definition}
    A \textbf{lattice graph} is a strongly connected directed
      multigraph in which each edge $e$ is labeled with a rigid body
      transformation $T(e)$ and each $\edge{v}{T(e)}{w}$ has an
      inverse edge $\edge{w}{T(e)^{-1}}{v}$.  
    \end{definition}
    \begin{columns}[T] % align columns
      \begin{column}{.45\textwidth}
        \begin{figure}
          \centering
          \begin{tikzpicture}[->,>=stealth',shorten >=5pt,auto,node distance=1cm]
            \tikzstyle{every state}=[fill=purple,draw=none, text=white]
            \node[state, scale=0.6] (A)         {$0$};
            \path (A) edge [loop above] node {\footnotesize{Tr(0, 40)}} (A)
                      edge [loop left]  node {\footnotesize{Tr(-40,0)}} (A)
                      edge [loop below] node {\footnotesize{Tr(0, -40)}} (A)
                      edge [loop right] node {\footnotesize{Tr(40, 0)}} (A);
          \end{tikzpicture}
        \end{figure}
      \end{column}%
      \begin{column}{.45\textwidth}
        \begin{figure}
          \centering
          \includegraphics[scale=1]{figs/squarelattice}
        \end{figure}
      \end{column}%
    \end{columns}
\end{frame}
\begin{frame}{Simulation Example}{Square formation with 10 robots}
  \begin{center}
  \includemovie[toolbar, poster, autoplay]{6cm}{6cm}{videos/square10.mp4}
  \end{center}
\end{frame}
\begin{frame}{Role Function}
  \begin{definition}
    \small{Given a lattice graph $G=(V, E)$ and a set of robots $R = \{
    r_1, \ldots, r_n \}$, $R$ \textbf{satisfies} $G$ if
    there exists a role function $f: R \rightarrow V$ that preserves
    the neighborhood structure of $G$.
    \\
    Specifically, for any $i$ and $j$, if $r_i$ and $r_j$ are neighbors, 
    there must exist an edge
    $e_{ij}: \edge{f(r_i)}{}{f(r_j)}$ in $E$, such that
    $ T(r_j) = T(r_i) T(e_{ij})$.}
  \end{definition}
  \begin{columns}[T] 
    \begin{column}{.4\textwidth}
      \begin{figure}
        \centering
        % \includegraphics[scale=0.38]{figs/hex}
        \begin{tikzpicture}[->,>=stealth',shorten >=5pt,auto,node
          distance=1cm]
            \tikzstyle{every state}=[fill=purple, draw=none, text=white]
            \node[state, scale=0.6] (A) at (0,0)    {$0$};
            \node[state, scale=0.6, fill=cyan] (B) at (3,0)  {$1$};
            \path (A) edge [bend left=10] node {\scriptsize{Tr(0, 40)}} (B)
                  (A) edge [bend left=45] node {\scriptsize{Tr(-35,-20)}} (B)
                  (A) edge [bend left=90] node
                  {\scriptsize{Tr(35,-20)}} (B)
                  (B) edge [bend left=10]  node {\scriptsize{Tr(-40,0)}} (A)
                  (B) edge [bend left=45]  node
                  {\scriptsize{Tr(35,20)}} (A)
                  (B) edge [bend left=90]  node {\scriptsize{Tr(-35,20)}} (A);
        \end{tikzpicture}
      \end{figure}
    \end{column}%
    \begin{column}{.5\textwidth}
      \begin{figure}
        \centering
        \includegraphics[width=0.75\linewidth]{figs/bad-hexagon}
      \end{figure}
      \begin{figure}
        \centering
        \includegraphics[scale=0.8]{figs/good-hexagon}
        \end{figure}
    \end{column}%
  \end{columns}
\end{frame}

\begin{frame}{Evaluation Criteria}
  \begin{itemize}
  \item Efficiency\\
    %\begin{definition}
    A robot $r_i$ is \textbf{static} at time $t$ if its pose $p_i$
    remains the same at all future times, so that 
    $$p_i(t') = p_i(t) \quad \mbox {for all } t' > t$$    
  %\end{definition}
  Define the \textbf{execution time} $\bar{t}$ of the system as the smallest time
  when all the robots reach in static states
  \item Quality \\
    When all robots reach static positions, for a robot $r_i$
    with $N_i$ neighbors and $E_i$ outgoing edges from its role vertex. 
    Define a non-fulfillment ratio:
    $$\Gamma = \dfrac{1}{n}\sum\limits_{i=1}^n \frac{E_i - N_i}{E_i}$$
    to measure the overall lattice quality
  \end{itemize}
  
\end{frame}

\begin{frame}{Self-Consistent Lattice Graph}
  \begin{definition}
    \small{Given a range $\phi > 0$, call a lattice graph
      \textit{self-consistent} for this range if, for any two paths with the
      same starting node,
    $$\lgpath{v}{T(e_v^{k})}{T(e_m^{w})}{w}, \text{ and }\lgpath{v}{T(e_v^{j})}{T(e_n^{u})}{u},$$
    for which the distance between two ending nodes is less than or equal to
    $\phi$, there exist edges between $w$ and $u$.}
    \end{definition}
    \begin{columns}[T] % align columns
      \begin{column}{.45\textwidth}
        \begin{figure}
          \centering
          \begin{tikzpicture}
            \tikzstyle{every state}=[fill=red!50, draw=none]
            \node[state, scale=0.7] (A) at (2.5,0)  {\large{$v$}};
            \node[state, scale=0.7] (C) at (0, 0.75) {\large{$w$}};
            \node[state, scale=0.7] (D) at (0, -0.75) {\large{$u$}};
            \draw[arc] (A) to[out=150, in=0] (C);
            \draw[arc] (A) to[out=-150,in=0] (D);
            \draw[arc] (C) to[out=-30, in=170] (A);
            \draw[arc] (D) to[out=30, in=-170] (A);
            \node[] at (1, -1.2) {\scriptsize{$\left(0, l, 0\right)$}};
            \node[] at (1, 1.2) {\scriptsize{$\left(\dfrac{l}{2}, l, 0\right)$}};
            % \node[] at (-0.5, 0) {\scriptsize{$(\dfrac{\range}{2}, 0, 0)$}};
          \end{tikzpicture}
          % \caption{A lattice graph not self-consistent when $\phi > l$. The
          %   distance between robots with roles $w$ and $u$ is less than $l/2 <
          %   \phi$, but no edge connects $w$ and $u$.}
        \end{figure}
      \end{column}%
      \begin{column}{.45\textwidth}
        \begin{figure}
          \centering
        \begin{tikzpicture}
           \tikzstyle{every state}=[fill=red!50, draw=none]
       \node[state, scale=0.7] (A) at (2.5,0)   {\large{$v$}};
       \node[state, scale=0.7] (C) at (0, 0.75) {\large{$w$}};
       \node[state, scale=0.7] (D) at (0, -0.75) {\large{$u$}};
       \draw[arc] (A) to[out=150, in=0] (C);
       \draw[arc] (A) to[out=-150,in=0] (D);
       \draw[arc] (C) to[out=-30, in=170] (A);
       \draw[arc] (D) to[out=30, in=-170] (A);
       \draw[arc] (C) to[out=-60, in=60] (D);
       \draw[arc] (D) to[out=120, in=-120] (C);
       \node[] at (1, -1.2) {\scriptsize{$\left(0, l, 0\right)$}};
       \node[] at (1, 1.2) {\scriptsize{$\left(\dfrac{l}{2}, l, 0\right)$}};
       \node[] at (-1, 0) {\scriptsize{$\left(\dfrac{l}{2}, 0, 0\right)$}};
     \end{tikzpicture}
      % \caption{A lattice graph that is self-consistent when $\phi > l$.}
        \end{figure}
      \end{column}%
    \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algorithm}
\begin{frame}{Algorithm}
  \textbf{General Description}
  \begin{columns}[T] % align columns
   \begin{column}{.4\textwidth}
     Robot broadcasts message containing its
     \begin{itemize}
     \item \textcolor{red}{authority} 
     \item \textcolor{red}{matching}
     \item \textcolor{red}{opening}
     \end{itemize}

      \begin{enumerate}
      \item Form tree structure
      \item Select roles
      \item Use tree structure to compute local task assignment
      \item Make movement decision
      \end{enumerate}
    \end{column}%
    \begin{column}{.5\textwidth}
      \begin{animateinline}[
        begin={%
          \begin{tikzpicture}%
           [post/.style={->,>=stealth', semithick, draw=blue!50},
            node/.style={circle,fill=red!20,draw,font=\sffamily\small}]%
            \useasboundingbox (0,0) rectangle (5,5);
          },
          end={\end{tikzpicture}}
        ]{10}
         %\draw[dotted, violet, fill=violet!10] (3, 3) circle (3.5);
         \draw[fill=blue!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
         % \node[color=black] at (3, 4.5) {broadcast Message};           
         \draw[fill=blue!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) -- (0.67,4) -- cycle;
         \draw[fill=blue!50] (1,1.5) -- (1.25,1) -- (1.25,1.25) --
         (1.5,1.25) -- cycle;
         \newframe*
         \multiframe{10}{rP = 0.1 +.1, r = 1 + 1}{ 
           \draw[fill=blue!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
           \node[color=black] at (3, 4.5) {broadcast Message};           
           \draw[fill=blue!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) -- (0.67,4) -- cycle;
           \draw[fill=blue!50] (1,1.5) -- (1.25,1) -- (1.25,1.25) --
           (1.5,1.25) -- cycle;
           \path (3,3) -- (1.25, 1.25) node[pos=\rP] (q){};
           \draw[post] (3,3) -- (q.west);
           
           \path (3,3) -- (0.5, 4.125) node[pos=\rP] (q){};
           \draw[post] (3,3) -- (q.west);
           
           \path (1.5, 1.25) -- (3,2.5) node[pos=\rP] (q){};
           \draw[post] (1.5, 1.25) -- (q.west);
           
           \path (1.25, 1.5) -- (0.5, 4.125) node[pos=\rP] (q){};
           \draw[post] (1.25, 1.5) -- (q.south);
           
           \path (0.5, 4.5) -- (3.25, 3.25) node[pos=\rP] (q){};
           \draw[post] (0.5, 4.5) -- (q.north);

           \path (0.33, 4) -- (1, 1.5) node[pos=\rP] (q){};
           \draw[post] (0.33, 4) -- (q.north);
        }
        \newframe*
        \multiframe{10}{rP = 0.1 +.1, r = 1 + 1}{ 
         \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
         \node[color=red] at (3, 2.3) {$root$};           
         \draw[fill=blue] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
         (0.67,4) 	-- cycle;
         \node[color=blue] at (1, 3.75) {$descendant$};           
         \draw[fill=blue] (1,1.5) -- (1.25,1) -- (1.25,1.25) -- (1.5,1.25)  -- cycle;
         \node[color=blue] at (2.5,1.5) {$descendant$};
         \node[color=black] at (3, 4.5) {Form Tree Structure};
         \path (3,3) -- (1.25, 1.25) node[pos=\rP] (q){};
         \draw[post, color=red] (3,3) -- (q);
           
         \path (3,3) -- (0.5, 4.125) node[pos=\rP] (q){};
         \draw[post, color=red] (3,3) -- (q);
        }
        \newframe*
        \multiframe{10}{r = 1 + 1}{ 
          \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
          \draw[fill=blue] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
         (0.67,4) 	-- cycle;
         \draw[fill=blue] (1,1.5) -- (1.25,1) -- (1.25,1.25) -- (1.5,1.25)  -- cycle;
         \node[color=black] at (3, 4.5) {Assign Task};  
         %\path (3,3) -- (1.25, 1.25) node[pos=\rP] (q){};
         \draw[post, color=red] (3,3) -- (1.25, 1.25);
         % \path (3,3) -- (0.5, 4.125) node[pos=\rP] (q){};
         \draw[post, color=red] (3,3) -- (0.5,4.125);
         \draw[red, dotted] (1,3) -- (0.75,3) -- (1.25,3.25) -- (1,2.75) -- cycle;
         \draw[red, dotted] (3,1) -- (2.75,1) -- (3.25,1.25) -- (3,0.75) -- cycle;
         \draw[dashed](1.25,1.25) -- (3,1);
         \draw[dashed](0.5,4.125) -- (1,3);
        }
        \newframe*
        \multiframe{10}{r = 1 + 1}{ 
          \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
          \node[color=black] at (3, 4.5) {Movement Control};  
          \draw[post, color=red] (3,3) -- (1,3);
          \draw[post, color=red] (3,3) -- (3,1);
          \draw[fill=blue] (1,3) -- (0.75,3) -- (1.25,3.25) -- (1,2.75) -- cycle;
          \draw[fill=blue] (3,1) -- (2.75,1) -- (3.25,1.25) -- (3,0.75) -- cycle;
        }
      \end{animateinline}
    \end{column}%
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%
\subsubsection{Authority Tree}
\begin{frame}{Authority}
  \textbf{Define authority and comparison operator}
    %\begin{bclogo}[logo=\bccrayon,couleur=orange!10, arrondi=0.1,ombre=true]{}
      \begin{definition}
      \small{An \textbf{authority} is an ordered list of robot IDs
        $$(\id_1, \ldots, \id_k)$$
        The first ID in the list, $\id_1$ is called the \textbf{root} ID.
        The final ID in the list, $\id_k$ is called the \textbf{sender} ID.}
%        The number of IDs in the list is called its \textbf{length}}
    %\end{bclogo}
    \end{definition}
    \begin{definition}
    %\begin{bclogo}[logo=\bccrayon,couleur=orange!10, arrondi=0.1, ombre=true]{}
      \small{Authority $A_2$ is \textbf{higher than} $A_1$ if:}
      \begin{itemize}
      \item \small{root ID of $A_2 >$ root ID of $A_1$, or}
      \item \small{length of $A_2 <$  length of $A_1$ if they have the same root, or}
      \item \small{sender ID of $A_2 >$ sender ID of $A_1$ if they have the same root and length}
      \end{itemize}
    %\end{bclogo}
    \end{definition}
\end{frame}

%%%%%%%%%%%%%%%%

% help me iron out the bugs or give me some comment and suggestions
\begin{frame}{1.Construct Authority Tree}{Decide to be root or descendant}
  \textbf{Key Idea:} Each robot forms an authority containing only its own ID,
  compares it with the authorities of remaining messages. The robots use these
  authorities to establish a collection of authority trees
  \begin{columns}[T] % align columns
    \begin{column}{.45\textwidth}
      \begin{itemize}
      \item \footnotesize{If its authority is the highest, then it is
        a \textcolor{red}{root}}
      \item \footnotesize{It selects the one who sends the highest
        authority and has matching with it as its parent.
        Append its own ID to the parent's
        authority to create its own authority}
      \item \footnotesize{Otherwise, it is an \textcolor{blue}{orphan}.}
      \end{itemize}     
    \end{column}%
    \begin{column}{.5\textwidth}
       \begin{animateinline}[
        begin={%
          \begin{tikzpicture}%
           [post/.style={->,>=stealth', thick, draw=blue!50},
            node/.style={circle,fill=red!20,draw,font=\sffamily\small}]%
            \useasboundingbox (0,1) rectangle (5,5);
          },
          end={\end{tikzpicture}}
        ]{10}
        \draw[dashed, blue] (3, 4) circle (3);
        % center is (3,4)
        \draw[fill=blue!50] (3,4) -- (2.75,4) -- (3.25,4.25) -- (3,3.75)  -- cycle;
        \node[color=blue] at (2.75, 3.5) {$(2)$};
        % center is (0.5, 4.5)
        \draw[dashed, green] (0.5,4.5) circle (2.8);
        \draw[fill=green!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
        (0.67,4) -- cycle;
        \node[color=green] at (0.5, 3.75) {$(4)$};
        % center is (3.75,2)
        \draw[dashed, red] (3.75,2) circle (2.5);
         \draw[fill=red!50] (3.5,2.5) -- (3.75,2) -- (3.75,2.25) --
         (4,2.25) -- cycle;
         \node[color=red] at (3.3, 2) {$(3)$};
         %%%%
        \newframe*
        \multiframe{10}{rP= 0.1+ .1, r = 1 + 1}{ 
          \draw[dashed, blue] (3, 4) circle (3);
          % center is (3,4)
          \draw[fill=blue!50] (3,4) -- (2.75,4) -- (3.25,4.25) --
          (3,3.75)  -- cycle;
          \node[color=blue] at (2.75, 3.5) {$(4,2)$};
          % center is (0.5, 4.5)
          \draw[dashed, green] (0.5,4.5) circle (2.8);
          \draw[fill=green!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
          (0.67,4) -- cycle;
          \node[color=green] at (0.5, 3.75) {$(4)$};
          % center is (3.75,2)
          \draw[dashed, red] (3.75,2) circle (2.5);
          \draw[fill=red!50] (3.5,2.5) -- (3.75,2) -- (3.75,2.25) --
          (4,2.25) -- cycle;
          \node[color=red] at (3.3, 2) {$(3)$};
          \path (0.5,4.125) -- (3,4) node[pos=\rP] (q){};
          \draw[post] (0.5,4.125) -- (q);
        }
        \newframe*
        \multiframe{10}{r = 1 + 1}{ 
          \draw[dashed, blue] (3, 4) circle (3);
          % center is (3,4)
          \draw[fill=blue!50] (3,4) -- (2.75,4) -- (3.25,4.25) --
          (3,3.75)  -- cycle;
          \node[color=blue] at (2.75, 3.5) {$(4,2)$};
          % center is (0.5, 4.5)
          \draw[dashed, green] (0.5,4.5) circle (2.8);
          \draw[fill=green!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
          (0.67,4) -- cycle;
          \node[color=green] at (0.5, 3.75) {$(4)$};
          % center is (3.75,2)
          \draw[dashed, red] (3.75,2) circle (2.5);
          \draw[fill=red!50] (3.5,2.5) -- (3.75,2) -- (3.75,2.25) --
          (4,2.25) -- cycle;
          \node[color=red] at (3, 2) {$(4,2,3)$};
          \draw[post] (0.5,4.125) -- (2.87,4);
        }
         \newframe*
         \multiframe{10}{rP = 0.1 +.1, r = 1 + 1}{ 
           \draw[dashed, blue] (3, 4) circle (3);
          % center is (3,4)
          \draw[fill=blue!50] (3,4) -- (2.75,4) -- (3.25,4.25) --
          (3,3.75)  -- cycle;
          \node[color=blue] at (2.75, 3.5) {$(4,2)$};
          % center is (0.5, 4.5)
          \draw[dashed, green] (0.5,4.5) circle (2.8);
          \draw[fill=green!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) --
          (0.67,4) -- cycle;
          \node[color=green] at (0.5, 3.75) {$(4)$};
          % center is (3.75,2.25)
          \draw[dashed, red] (3.75,2) circle (2.5);
          \draw[fill=red!50] (3.5,2.5) -- (3.75,2) -- (3.75,2.25) --
          (4,2.25) -- cycle;
          \node[color=red] at (3, 2) {$(4,2,3)$};
          \draw[post] (0.5,4.125) -- (2.87,4);

          \path (3,4) -- (3.75, 2.25) node[pos=\rP] (q){};
          \draw[post] (3,4) -- (q);        
        }
      \end{animateinline}
    \end{column}
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%
\subsubsection{Task Assignment}
\begin{frame}{Matching}{}
  % Given a robot $r_i$ and a role vertex $v_i$ for that
  % robot, let the lattice graph edge set $L=\{\emptyset,e_{ij}, e_{ik},
  % \ldots\}$ be the set that contains a null value $\emptyset$ and all
  % outgoing edges from vertex $v_i$. Let $Q=\{\id(r_a), \id(r_b),
  % \ldots \}$ be the set that contains the IDs of the neighbors of $r_i$.  
  \begin{columns}[T] 
    \begin{column}{.35\textwidth}
      %\begin{bclogo}[logo=\bccrayon,arrondi=0.1]{} 
      \begin{definition}    
     \small{A \textbf{matching} for a robot is a function $\eta : \{\id(r_a),
       \id(r_b), \ldots \} \rightarrow \{\emptyset,e_{ij}, e_{ik},
       \ldots\} $ that associates each neighbor ID with either a lattice
       graph edge from its role vertex or with the null value
       $\emptyset$.}
   \end{definition}
   %\end{bclogo}   
  \end{column}%
  \begin{column}{.55\textwidth}
      \begin{figure}
        % \centering
        \begin{tikzpicture}[
          fsnode/.style={},
          ssnode/.style={},
          every fit/.style={ellipse,draw,inner sep=0pt,text width=1cm},
          ->,shorten >= 2pt,shorten <= 2pt
          ]
          % the vertices of Q
          \begin{scope}[start chain=going below,node distance=1mm]
            \foreach \i/\xcoord in {1/\id(r_a),2/\id(r_b),3/\vdots, 4/\id(r_c)}
            \node[fsnode,on chain] (f\i) {$\xcoord$};
          \end{scope}
          % the vertices of L
          \begin{scope}[xshift=3cm,start chain=going below,node distance=1mm]
            \foreach \i/\xcoord in {5/e_{ij},6/e_{ik}, 7/\vdots, 8/\emptyset}
            \node[ssnode,on chain] (s\i) {$\xcoord$};
          \end{scope}         
          % the set U
          %\node [myblue,fit=(f1) (f4),label=below:$Q$] {};
          \node [myblue,fit=(f1) (f4), label=above:$$] {};
          % the set V
          \node [mygreen,fit=(s5) (s8), label=above:$$] {};
          % the edges
          \draw (f1) -- (s6);
          \draw (f2) -- (s5);
          \draw (f4) -- (s8);
        \end{tikzpicture}
      \end{figure}
    \end{column}%
  \end{columns}
  
\end{frame}

\begin{frame}{2. Local Task Assignment}{Hungarain Algorithm}
  To compute an optimal matching of a robot with $N$ neighbors and $E$
  out-going edges of its role in the lattice graph, define a weight
  matrix of size $\min(N,E) \times E$ and apply
  \textcolor{scred}{Hungarian Algorithm} (Harold W. Kuhn, 1955).
    \begin{columns}[T] % align columns
      \begin{column}{.4\textwidth}
        \begin{enumerate}
        \item \small{Each row corresponds to a neighbor}
        \item \small{Each column corresponds to an out-going edge of robot's role}
        \item \small{The entries of the matrix are the Euclidean distance
          between current position of each neighbor and the desired
          position if matched with a lattice graph edge}
        \end{enumerate}
      \end{column}%
      \begin{column}{.5\textwidth}
        \vspace{3mm}
           \begin{animateinline}[
             begin={%
               \begin{tikzpicture}%
                 [post/.style={->,>=stealth', thin, draw=blue!50},
                 node/.style={circle,fill=red!20,draw,font=\sffamily\small},
                 scale=0.8]%
                 %\useasboundingbox (0,0) rectangle (5,5);
               },
               end={\end{tikzpicture}}
             ]{10}
             \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75) -- cycle;
             \draw[fill=blue!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125)
             -- (0.67,4) -- cycle;
             \draw[fill=blue!50] (4,5) -- (3.75,5.5) -- (3.75,5.25) -- (3.5,5.25)   	-- cycle;
             \draw[fill=blue!50] (1,2.5) -- (1.25,2) -- (1.25,2.25) -- (1.5,2.25)   	-- cycle;
             \draw[fill=blue!50] (5,2.92) -- (4.5,2.75) -- (5,2.58) -- (4.875,2.75)  -- cycle;
             \draw[fill=blue!50] (-0.5,2.5) -- (-0.5,2.75) -- (-0.75,2.25) -- (-0.25,2.5)  -- cycle;
             \draw[color=red] (4,4) -- (3.75,4) -- (4.25,4.25) -- (4,3.75) -- cycle;
             \draw[color=red] (2,2) -- (1.75,2) -- (2.25,2.25) -- (2,1.75) -- cycle;
             \draw[color=red] (2,4) -- (1.75,4) -- (2.25,4.25) -- (2,3.75) -- cycle;
             \draw[color=red] (4,2) -- (3.75,2) -- (4.25,2.25) -- (4,1.75) -- cycle;
             \newframe*
             \multiframe{10}{r = 1 + 1}{ 
               \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)   	-- cycle;
               \draw[fill=blue!50] (0.5,4.5) -- (0.33,4) -- (0.5,4.125) -- (0.67,4) 	-- cycle;
               \draw[fill=blue!50] (4,5) -- (3.75,5.5) -- (3.75,5.25) -- (3.5,5.25)   	-- cycle;
               \draw[fill=blue!50] (1,2.5) -- (1.25,2) -- (1.25,2.25) -- (1.5,2.25)   	-- cycle;
               \draw[fill=blue!50] (5,2.92) -- (4.5,2.75) -- (5,2.58) -- (4.875,2.75)  -- cycle;
               \draw[fill=blue!50] (-0.5,2.5) -- (-0.5,2.75) -- (-0.75,2.25) -- (-0.25,2.5)  -- cycle;
               
               \draw[color=red] (4,4) -- (3.75,4) -- (4.25,4.25) -- (4,3.75) -- cycle;
               \draw[color=red] (2,2) -- (1.75,2) -- (2.25,2.25) -- (2,1.75) -- cycle;
               \draw[color=red] (2,4) -- (1.75,4) -- (2.25,4.25) -- (2,3.75) -- cycle;
               \draw[color=red] (4,2) -- (3.75,2) -- (4.25,2.25) -- (4,1.75) -- cycle;
               
               \draw[dashed](0.5, 4.25) -- (2,4);
               \draw[dashed](1.25,2.25) -- (2,2);
               \draw[dashed](3.75,5.25) -- (4,4);
               \draw[dashed](4.75,2.75) -- (4,2);
             }
        \end{animateinline}
        \vspace{3mm}
        \begin{flushleft}
          \footnotesize{5 neighbors, 4 out-going edges.}
        \end{flushleft}
        
      \end{column}%
    \end{columns}
\end{frame}
\begin{frame}{Opening}{}
   %\begin{bclogo}[logo=\bccrayon,arrondi=0.1]{Definition} 
  \begin{definition}
    An \textbf{opening} is a position where there is no robot and is
     not assigned by any robot yet.
   \end{definition}
   \begin{columns}[T] % align columns
   \begin{column}{.45\textwidth}
     An opening can be found by a robot:
     \begin{itemize}
     \item \small{locally, if the number of its neighbors is less than its
       out-degree, or}
     \item \small{choosing the nearest position from received messages}
     \end{itemize}
    \end{column}%
    \begin{column}{.5\textwidth}
      \begin{animateinline}[
        begin={%
          \begin{tikzpicture}%
           [post/.style={->,>=stealth', semithick, draw=blue!50},
            node/.style={circle,fill=red!20,draw,font=\sffamily\small}]%
            \useasboundingbox (-1.5,0) rectangle (3.5,3.7);
          },
          end={\end{tikzpicture}}
        ]{10}
        \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
          \node[color=black] at (1, 4.7) {local opening};  
          \draw[fill=blue] (1,3) -- (0.75,3) -- (1.25,3.25) -- (1,2.75) -- cycle;
          \draw[red, dashed] (3,1) -- (2.75,1) -- (3.25,1.25) --
          (3,0.75) -- cycle;
          \draw[dashed] (3,1) -- (3,3);
          \draw[post, color=red] (3,3) -- (1,3);
          \node[color=black] at (2.75, 3.5) {$(10)$};
        \newframe*
        \multiframe{10}{r = 1 + 1}{ 
          \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
          \node[color=black] at (1, 4.7) {opening from messages};  
          \draw[post, color=red] (3,3) -- (1,3);
          \draw[post, color=red] (3,3) -- (3,1);
          \draw[fill=blue] (1,3) -- (0.75,3) -- (1.25,3.25) -- (1,2.75) -- cycle;
          \draw[fill=blue] (3,1) -- (2.75,1) -- (3.25,1.25) --
          (3,0.75) -- cycle;
          \draw[blue, dashed] (1,1) -- (0.75,1) -- (1.25,1.25) --
          (1,0.75) -- cycle;
          \draw[blue, dashed] (-1,3) -- (-1.25,3) -- (-0.75,3.25) --
          (-1,2.75) -- cycle;
          \draw[dashed] (1,1) -- (3,1);
          \draw[dashed] (-1,3) -- (1,3);
          \node[color=black] at (2.75, 3.5) {$(10\sqrt{2})$};
        }
      \end{animateinline}
    \end{column}%
  \end{columns}
\end{frame}
\begin{frame}{Example}{Line formation}
  \begin{columns}
    \begin{column}{.4\textwidth}
      \begin{figure}
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=5pt,auto,node
          distance=1cm]
            \tikzstyle{every state}=[fill=purple, draw=none, text=white]
            \node[state, scale=0.6] (A) at (0,0)    {$0$};
            \path (A) edge [loop above] node {\footnotesize{Tr(40, 0)}} (A)
                      edge [loop below] node {\footnotesize{Tr(-40, 0)}} (A);
        \end{tikzpicture}
        \caption{Lattice graph to represent a single line.}
      \end{figure}
    \end{column}
    \begin{column}{.55\textwidth}
      \begin{center}
      \includemovie[toolbar,poster,autoplay]{5cm}{5cm}{videos/line.mp4}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%
\subsubsection{Motion Strategy}
\begin{frame}{3. Robot Movement Strategy}{}
  % Define block styles
\tikzstyle{decision} = [diamond, draw, fill=red!10, 
    text width=4em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!10, 
    text width=5em, text centered, rounded corners]%, minimum height=2em]
\tikzstyle{line} = [draw, -latex']

\begin{figure}    
  \centering
  \begin{tikzpicture}
    \node [block] (init) {\footnotesize{Start}};
    \node [decision, below of=init, node distance=2cm] (decide) {\footnotesize{Root?}};
    \node [block, below of=decide, node distance=2cm] (stop) {\footnotesize{Stay}};
    \node [decision, right of=decide, node distance=3.5cm] (decideagain) {\footnotesize{Assigned?}};
    \node [block, right of=decideagain, node distance=3.5cm, text width=6em] (away)
    {\footnotesize{Move towards nearest opening}};
    \node [block, below of=decideagain, node distance=3cm, text width=9em] (go)
    {\footnotesize{Move towards assigned destination}};
    % Draw edges
    \path [line] (init) -- (decide);
    \path [line] (decide) -- node [xshift=-0.5cm]{yes}(stop);
    \path [line] (decide) -- (stop);
    \path [line] (decide) -- node [yshift=0.3cm] {no} (decideagain);
    \path [line] (decideagain) -- node [yshift=0.3cm] {no} (away);
    \path [line] (decideagain) -- node [xshift=-0.5cm] {yes} (go);
  \end{tikzpicture}
  \end{figure}
\end{frame}
%%%%%%%%%%%%%%%%
\begin{frame}{Bounded Movement}{}
  \textbf{Goal: let descendant stay in the range of its parent}
    \begin{columns}[T] % align columns
      \begin{column}{.4\textwidth}
        \begin{itemize}
        \item \footnotesize{Within the set $O$ (\textcolor{red}{Red circle}), the
          parent is guaranteed to get observation at next stage}
        \item \footnotesize{Descendant can reach anywhere in set $P$
          (\textcolor{blue}{blue circle}) at next stage}
        \item \footnotesize{The real destination for descendant is the closest point
          on the boundary of the intersection ($O\cap P$) to the
          assigned destination}
        \end{itemize}
      \end{column}%
      \begin{column}{.5\textwidth}
        \def\parentcircle{(3,3) circle (2cm)}
        \def\childcircle{(1,4) circle (1cm)}
        \begin{animateinline}[
          begin={%
            \begin{tikzpicture}%
              [post/.style={->,>=stealth', thick, draw=blue!50},
              node/.style={circle,fill=red!20,draw,font=\sffamily\small}]
              \useasboundingbox (0,1) rectangle (5.1,5.1);
            },
            end={\end{tikzpicture}}
          ]{10}
          % center is (3,4)
          \draw[fill=red!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
          \node[color=red] at (3,3.5) {\scriptsize{Parent}};
          % center is (1, 4)
          \draw[fill=blue!50] (1,4) -- (0.75,4) -- (1.25,4.25) -- (1,3.75)  -- cycle;
          
          \node[color=blue] at (2.8, 1.2) {\scriptsize{Assigned
              Destination}};
          \draw[dashed] (2,2) -- (2.25,1.5) -- (2.25,1.75) --
          (2.5,1.75) -- cycle;
          %%%% 
          \newframe*
          \multiframe{10}{r = 1 + 1}{ 
            \draw[red] (3,3) circle (2);
            \begin{scope}
              \clip \parentcircle;
              \filldraw[fill=violet!20] \childcircle;
            \end{scope}  
            % center is (3,3)
            \draw[fill=red!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
            \node[color=red] at (3,3.5) {\scriptsize{Parent}};
            \draw[blue] (1, 4) circle (1);
            \draw[fill=blue!50] (1,4) -- (0.75,4) -- (1.25,4.25) --
            (1,3.75)  -- cycle;
            % center is (2.25, 1.75)
            \draw[dashed] (2,2) -- (2.25,1.5) -- (2.25,1.75) --
            (2.5,1.75) -- cycle;
            \node[color=blue] at (2.8, 1.2) {\scriptsize{Assigned Destination}};
          }
          \newframe*
          \multiframe{10}{r = 1 + 1}{ 
             \begin{scope}
              \clip \parentcircle;
              \filldraw[fill=violet!20] \childcircle;
            \end{scope}  
            \draw[fill=red!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75)  -- cycle;
            \node[color=red] at (3,3.5) {\scriptsize{Parent}};
            \draw[fill=blue!50] (1,4) -- (0.75,4) -- (1.25,4.25) --
            (1,3.75)  -- cycle;
            % intersected point is (1,3)
            \draw[fill=blue] (1.48, 3.12) circle (0.05);
            \node[color=blue] at (1.2, 2.5) {\scriptsize{Real Destination}};
            \draw[dashed] (2,2) -- (2.25,1.5) -- (2.25,1.75) --
            (2.5,1.75) -- cycle;
            \node[color=blue] at (2.8, 1.2) {\scriptsize{Assigned Destination}};
          }
        \end{animateinline}
     
      \end{column}%
    \end{columns} 
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \begin{frame}
%     \href{run:shell.command}{here}
% \end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[future]{Objectives and Future Work}
\begin{frame}{Objectives and Future Work}{}
  \begin{enumerate}
  \item Self-consistent Lattice Graph Evaluation
    \begin{itemize}
    \item Determine if a given lattice graph is self-consistent
    \end{itemize}
  \item Algorithm Evaluation and Optimization
    \begin{itemize}
    \item Collect measurements of experiments
    \item Optimize performance: potential-field-like methods
    \end{itemize}
  \item Algorithm Correctness
    \begin{itemize}
    \item Improve motion strategy
    \item Determine if a given lattice graph is connected satisfiable for $k$
      robots
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}{Objectives}{Self-consistent Lattice Graph Evaluation}
  \textbf{Key: How to determine if a path ending at the same position as its
    starting position in finite steps?}
  \begin{columns}
    \begin{column}{0.3\textwidth}
      \begin{figure}[center]
        \centering
        \begin{tikzpicture}[->,>=stealth',node distance=5cm]
          \tikzstyle{every state}=[fill=red!50,draw=none]
          \node[state, scale=0.8] (A)    {$0$};
          \path (A) edge [loop above] node {\footnotesize{R($90^\circ$)Tr(0, 10)}} (A)
                    edge [loop below] node {\footnotesize{Tr(0,-10)R($-90^\circ$)}} (A);
                  \end{tikzpicture}
                  \caption{Lattice graph A}
                \end{figure}
    \end{column}
    \begin{column}{0.3\textwidth}
      \begin{figure}[center]
        \centering
         \begin{tikzpicture}
    \draw[fill=red] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75) -- cycle;
    \draw[fill=red!50] (1,3) -- (1,3.25) -- (0.75,2.75) -- (1.25,3)  -- cycle;
    \draw[fill=red!50] (2.25,1.75) -- (2,2.25) -- (2,2) -- (1.75,2) -- cycle;
    \draw[fill=red!50] (1.75,4.25) -- (2,3.75) -- (2, 4) -- (2.25,4) --  cycle;
    \draw[dashed](1,3) -- (2,4);
    \draw[dashed](3,3) -- (2,4);
    \draw[dashed](3,3) -- (2,2);
    \draw[dashed](1,3) -- (2,2);
  \end{tikzpicture}
        \caption{A lattice satisfying graph A}
      \end{figure}
    \end{column}
    \begin{column}{0.3\textwidth}
      \begin{figure}[center]
        \centering
         \begin{tikzpicture}[->,>=stealth',node distance=5cm]
      \tikzstyle{every state}=[fill=red!50,draw=none]
      \node[state, scale=0.8] (A)    {$0$};
      \path (A) edge [loop above] node {\footnotesize{Tr(10,0)R($45\sqrt{2}^\circ$)}} (A)
                edge [loop below] node {\footnotesize{R($-45\sqrt{2}^\circ$)Tr(-10,0)}} (A);
    \end{tikzpicture}
        \caption{Lattice graph B}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Objectives}{Algorithm Correctness}
  \textbf{Problem: } Some self-consistent lattice graphs implicitly limits the
  number of participants (Lattice graph A).
  \begin{columns}
    \begin{column}{0.35\textwidth}
      \begin{figure}
        \centering
        \begin{tikzpicture}
    \draw[fill=blue!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75) -- cycle;
    \draw[fill=blue!50] (1,3) -- (1,3.25) -- (0.75,2.75) -- (1.25,3)  -- cycle;
    \draw[fill=blue!50] (2.25,1.75) -- (2,2.25) -- (2,2) -- (1.75,2) -- cycle;
    \draw[fill=blue!50] (1.75,4.25) -- (2,3.75) -- (2,4) -- (2.25,4) --  cycle;
    \draw[dashed](1,3) -- (2,4);
    \draw[dashed](3,3) -- (2,4);
    \draw[dashed](3,3) -- (2,2);
    \draw[dashed](1,3) -- (2,2);
    \draw[fill=red!50] (4,3) -- (3.75,3) -- (4.25,3.25) -- (4,2.75) -- cycle;
    \draw[fill=red!50] (2,3) -- (2,3.25) -- (1.75,2.75) -- (2.25,3) -- cycle;
    \draw[fill=red!50] (3.25,1.75) -- (3,2.25) -- (3,2) -- (2.75,2) -- cycle;
    \draw[fill=red!50] (2.75,4.25) -- (3,3.75) -- (3,4) -- (3.25,4) --  cycle;
    \draw[dashed](2,3) -- (3,4);
    \draw[dashed](4,3) -- (3,4);
    \draw[dashed](4,3) -- (3,2);
    \draw[dashed](2,3) -- (3,2);

    \draw[dashed](2,3) -- (3,3);
    \draw[dashed](2,3) -- (2,4);
    \draw[dashed](2,3) -- (4,3);
    \draw[dashed](2,4) -- (3,4);
    \draw[dashed](3,3) -- (3,2);
    \draw[dashed](3,3) -- (3,4);
    \draw[dashed](2,3) -- (2,2);
    \draw[dashed](2,2) -- (3,2);
    \draw[dashed](1,3) -- (2,3);
  \end{tikzpicture}
  \caption{The positions of the robots do not satisfy
    the lattice graph A.}
      \end{figure}
    \end{column}
    \begin{column}{0.55\textwidth}
      \begin{figure}
        \centering
         \begin{tikzpicture}
    \draw[fill=blue!50] (3,3) -- (2.75,3) -- (3.25,3.25) -- (3,2.75) -- cycle;
    \draw[fill=blue!50] (1,3) -- (1,3.25) -- (0.75,2.75) -- (1.25,3)  -- cycle;
    \draw[fill=blue!50] (2.25,1.75) -- (2,2.25) -- (2,2) -- (1.75,2) -- cycle;
    \draw[fill=blue!50] (1.75,4.25) -- (2,3.75) -- (2,4) -- (2.25,4) --  cycle;
    \draw[dashed](1,3) -- (2,4);
    \draw[dashed](3,3) -- (2,4);
    \draw[dashed](3,3) -- (2,2);
    \draw[dashed](1,3) -- (2,2);
    \draw[fill=red!50] (7,3) -- (6.75,3) -- (7.25,3.25) -- (7,2.75) -- cycle;
    \draw[fill=red!50] (5,3) -- (5,3.25) -- (4.75,2.75) -- (5.25,3)  -- cycle;
    \draw[fill=red!50] (6.25,1.75) -- (6,2.25) -- (6,2) -- (5.75,2) -- cycle;
    \draw[fill=red!50] (5.75,4.25) -- (6,3.75) -- (6,4) -- (6.25,4) --  cycle;
    \draw[dashed](5,3) -- (6,4);
    \draw[dashed](7,3) -- (6,4);
    \draw[dashed](7,3) -- (6,2);
    \draw[dashed](5,3) -- (6,2);
  \end{tikzpicture}
  \caption{The positions of the robots satisfy the lattice graph A.}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}
  \begin{definition}
    A lattice graph is \textbf{connected satisfiable} for $k$ robots, if there
    exist $k$ robots whose positions satisfy the lattice graph and they are
    connected in communication.
  \end{definition}

  \textbf{Determine a prerequisite of applying our algorithm: } given a
  lattice graph, how to find the maximum $k$ for which the lattice graph is
  connected satisfiable?

\end{frame}
%%%%%%%%%%%%%%%%
\end{document}
